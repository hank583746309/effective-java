# Summary

* [介绍](README.md)
* [准备知识说明](ch0/README.md)
* [第一节：创建和销毁对象](ch1/README.md)
	* [用静态工厂方法替代构造器](ch1/01.md)
	* [遇到多个构造器参数时要考虑使用构建器](ch1/02.md)
	* [用私有构造器或者枚举类型强化Singleton属性](ch1/03.md)
	* [通过私有构造器强化不可实例化的能力](ch1/04.md)
	* [优先考虑依赖注入来饮用资源](ch1/05.md)
	* [避免创建不必要等对象](ch1/06.md)
	* [消除过期的对象引用](ch1/07.md)
	* [避免使用终结方法和清除方法](ch1/08.md)
	* [try-with-resources优先于try-finally](ch1/09.md)
* [第二节：对于所有对象都通用的方法](ch2/README.md)
	* [覆盖equals时请遵守约定](ch2/10.md)
	* [覆盖equals时总要覆盖hashCode](ch2/11.md)
	* [始终要覆盖toString](ch2/12.md) 
	* [谨慎覆盖clone](ch2/13.md)
	* [考虑实现Comparable接口](ch2/14.md)
* [第三节：类和接口](ch3/README.md)
	* [使类和成员的可访问性最小化](ch3/15.md)
	* [要在共有类而非公有域中使用访问方法](ch3/16.md)
	* [使可变性最小化](ch3/17.md)
	* [复合优先于继承](ch3/18.md) 
	* [要么设计继承并提供文档说明，要么禁止继承](ch3/19.md)
	* [接口优于抽象类](ch3/20.md)
	* [为后代设计接口](ch3/21.md)
	* [接口只用于定义类型](ch3/22.md)
	* [类层次优于标签类](ch3/23.md)
	* [静态成员类优于非静态成员类](ch3/24.md)
	* [限制源文件为单个顶级类](ch3/25.md)
* [第四节：范型](ch4/README.md)
	* [请不要使用原生态类型](ch4/26.md)
	* [消除非受检的警告](ch4/27.md)
	* [列表优于数组](ch4/28.md)
	* [优先考虑范型](ch4/29.md)
	* [优先考虑范型方法](ch4/30.md) 
	* [利用有限制通配符来提升API的灵活性](ch4/31.md) 
	* [谨慎并用反省和可变参数](ch4/32.md) 
	* [优先考虑类型安全的异构容器](ch4/33.md) 
* [第五节：枚举和注解](ch5/README.md)
	* [用enum代替int常量](ch5/34.md) 
	* [用实例域代替序数](ch5/35.md)
	* [用EnumSet代替位域](ch5/36.md)
	* [用EnumMap代替序数索引](ch5/37.md)
	* [用接口模拟可扩展的枚举](ch5/38.md)
	* [注解优先于命名模式](ch5/39.md)
	* [坚持使用Override注解](ch5/40.md)
	* [用标记接口定义类型](ch5/41.md)
* [第六节：Lambda 和 Stream](ch6/README.md)
	* [Lambda优先于匿名类](ch6/42.md)
	* [方法引用优先于Lambda](ch6/43.md)
	* [坚持使用标准的函数接口](ch6/44.md)
	* [谨慎使用Stream](ch6/45.md)
	* [优先选择Stream中无副作用的函数](ch6/46.md)
	* [Stream要优先于Collection作为返回类型](ch6/47.md)
	* [谨慎使用Stream并行](ch6/48.md)
* [第七节：方法](ch7/README.md)
	* [检查参数的有效性](ch7/49.md)
	* [必要时进行保护性拷贝](ch7/50.md) 
	* [谨慎设计方法签名](ch7/51.md) 
	* [慎用重载](ch7/52.md) 
	* [慎用可变参数](ch7/53.md) 
	* [返回零长度的数组或者集合而不是null](ch7/54.md) 
	* [谨慎返回optinal](ch7/55.md) 
	* [为所有导出的API元素编写文档注释](ch7/56.md) 
* [第八节：通用编程](ch8/README.md)
	* [将局部变量的作用域最小化](ch8/57.md)
	* [for-each循环优先于传统的for循环](ch8/58.md)
	* [了解和使用类库](ch8/59.md)
	* [如果需要精确的答案，请避免使用float和double](ch8/60.md)  
	* [基本类型优先于封装基本类型](ch8/61.md)  
	* [如果其他类型更适合，则尽量避免使用字符串](ch8/62.md)  
	* [了解字符串连接性能](ch8/63.md)  
	* [通过接口引用对象](ch8/64.md)  
	* [接口优先于反射机制](ch8/65.md)  
	* [谨慎地使用本地方法](ch8/66.md)  
	* [谨慎地进行优化](ch8/67.md)  
	* [遵守普遍接受的命名惯例](ch8/68.md)  
* [第九节：异常](ch9/README.md)
	* [只针对异常的情况才使用异常](ch9/69.md) 
	* [对可恢复的情况使用受检异常，对编程错误使用运行时异常](ch9/70.md)
	* [避免不必要地使用受检异常](ch9/71.md)
	* [优先使用标准的异常](ch9/72.md)
	* [抛出与抽象对应的异常](ch9/73.md)
	* [每个方法抛出的所有异常都要建立文档](ch9/74.md)
	* [在细节消息中包含失败--捕获信息](ch9/75.md)
	* [努力使失败保持原子性](ch9/76.md)
	* [不要忽略异常](ch9/77.md) 
* [第十节: 并发](ch10/README.md)
	* [同步访问共享的可变数据](ch10/78.md)
	* [避免过度同步](ch10/79.md)
	* [executor、task和stram优先于线程](ch10/80.md) 
	* [并发工具优先于wait和notify](ch10/81.md) 
	* [线程安全性的文档化](ch10/82.md) 
	* [慎用延迟初始化](ch10/83.md) 
	* [不要依赖于线程调度器](ch10/84.md) 
* [第十一节：序列化](ch11/README.md)
	* [其他方法优先于Java序列化](ch11/85.md)  
	* [谨慎地实现Serializable](ch11/86.md)  
	* [考虑使用自定义的序列化形式](ch11/87.md)  
	* [保护性地编写readObject方法](ch11/88.md)  
	* [对于实例控制，枚举类型优先于readResolve](ch11/89.md)
	* [考虑用序列化代理代替序列化实例](ch11/90.md)    
* [读后感](ch12/README.md)
